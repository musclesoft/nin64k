package main

import (
	"fmt"
	"os"
	"strings"
)

// 6502 Decompressor for V23 encoding
// All addresses are calculated dynamically - no hardcoded offsets

// Zero page layout
const (
	zpSrcLo      = 0x02 // Source pointer (compressed data)
	zpSrcHi      = 0x03
	zpBitBuf     = 0x04 // Current byte being read
	zpOutLo      = 0x05 // Output pointer
	zpOutHi      = 0x06
	zpValLo      = 0x07 // Multi-purpose: exp-golomb value, distance, length counter
	zpValHi      = 0x08
	zpRefLo      = 0x09 // Reference pointer (copy source)
	zpRefHi      = 0x0A
	zpOtherDelta = 0x0B // Delta to reach other buffer: (otherBase - selfBase) >> 8
	zpCallerX    = 0x0C // Caller's X saved by read_expgol (backref uses for adj 1/2/3)
)

// Terminator detection: must be > max gamma zeros in compressed data
// X counts down from 1: after N zeros, X = 1-(N+1) = -N (mod 256)
// Threshold = 256 - terminatorZeros detects exactly terminatorZeros consecutive zeros
const (
	TerminatorZeros     = 12   // number of zero bits that signal terminator
	terminatorThreshold = 256 - TerminatorZeros // $F4 for 12 zeros
)

// zpName returns the symbolic name for a zero page address
func zpName(addr byte) string {
	names := map[byte]string{
		0x02: "zp_src_lo", 0x03: "zp_src_hi",
		0x04: "zp_bitbuf",
		0x05: "zp_out_lo", 0x06: "zp_out_hi",
		0x07: "zp_val_lo", 0x08: "zp_val_hi",
		0x09: "zp_ref_lo", 0x0A: "zp_ref_hi",
		0x0B: "zp_other_delta", 0x0C: "zp_caller_x",
	}
	if name, ok := names[addr]; ok {
		return name
	}
	return fmt.Sprintf("$%02X", addr)
}

// GetDecompressorAsm returns the decompressor as ca65 assembly source code
// Generated by disassembling GetDecompressorCode()
func GetDecompressorAsm() string {
	code, labelMap := GetDecompressorCodeWithLabels()
	base := uint16(0x0D00)

	// Create reverse map: address -> label name
	labelNames := make(map[uint16]string)
	for name, offset := range labelMap {
		labelNames[base+uint16(offset)] = name
	}

	// Helper to get label name for an address
	labelFor := func(addr uint16) string {
		if name, ok := labelNames[addr]; ok {
			return name
		}
		return fmt.Sprintf("L%04X", addr)
	}

	var sb strings.Builder
	sb.WriteString(`; ============================================================================
; V23 Decompressor for 6502 - Generated from machine code
; ============================================================================
;
; Load address: $0D00
; Entry point:  decompress
;
; Setup required before calling:
;   $02-$03 (zp_src)    - Source pointer to compressed data
;   $04     (zp_bitbuf) - Bit buffer (set to $80 for first call)
;   $05-$06 (zp_out)    - Output pointer ($1000 or $7000)
;
; On return:
;   $02-$03 (zp_src)    - Updated source pointer
;   $04     (zp_bitbuf) - Updated bit buffer (pass to next call)
; ============================================================================

.setcpu "6502"

.segment "LOADADDR"
        .word   $0D00

.segment "CODE"

.proc decompress
`)

	// Collect branch targets for labels
	targets := make(map[uint16]bool)
	for i := 0; i < len(code); {
		op := code[i]
		size := opcodeSize(op)
		if size == 2 && isBranch(op) {
			offset := int8(code[i+1])
			target := uint16(int(base) + i + 2 + int(offset))
			targets[target] = true
		}
		if size == 3 && (op == 0x4C || op == 0x20) { // JMP/JSR
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			if target >= base && target < base+uint16(len(code)) {
				targets[target] = true
			}
		}
		i += size
	}

	// Disassemble
	for i := 0; i < len(code); {
		addr := base + uint16(i)

		// Label if this is a branch target
		if targets[addr] {
			sb.WriteString(fmt.Sprintf("%s:\n", labelFor(addr)))
		}

		op := code[i]
		size := opcodeSize(op)

		// Detect BIT abs skip trick: $2C followed by branch target at +1
		isBitSkip := op == 0x2C && i+1 < len(code) && targets[base+uint16(i+1)]
		if isBitSkip {
			size = 1 // Treat as single byte so hidden instruction is decoded
		}

		sb.WriteString(fmt.Sprintf("        "))

		switch op {
		// Implied
		case 0x00:
			sb.WriteString("brk")
		case 0x08:
			sb.WriteString("php")
		case 0x18:
			sb.WriteString("clc")
		case 0x38:
			sb.WriteString("sec")
		case 0x48:
			sb.WriteString("pha")
		case 0x28:
			sb.WriteString("plp")
		case 0x68:
			sb.WriteString("pla")
		case 0x8A:
			sb.WriteString("txa")
		case 0xCA:
			sb.WriteString("dex")
		case 0xE8:
			sb.WriteString("inx")
		case 0x98:
			sb.WriteString("tya")
		case 0xAA:
			sb.WriteString("tax")
		case 0xA8:
			sb.WriteString("tay")
		case 0x0A:
			sb.WriteString("asl a")
		case 0x4A:
			sb.WriteString("lsr a")
		case 0x2A:
			sb.WriteString("rol a")
		case 0x6A:
			sb.WriteString("ror a")
		case 0x60:
			sb.WriteString("rts")

		// Zero page
		case 0x05:
			sb.WriteString(fmt.Sprintf("ora     %s", zpName(code[i+1])))
		case 0x06:
			sb.WriteString(fmt.Sprintf("asl     %s", zpName(code[i+1])))
		case 0x26:
			sb.WriteString(fmt.Sprintf("rol     %s", zpName(code[i+1])))
		case 0x65:
			sb.WriteString(fmt.Sprintf("adc     %s", zpName(code[i+1])))
		case 0x84:
			sb.WriteString(fmt.Sprintf("sty     %s", zpName(code[i+1])))
		case 0x85:
			sb.WriteString(fmt.Sprintf("sta     %s", zpName(code[i+1])))
		case 0x86:
			sb.WriteString(fmt.Sprintf("stx     %s", zpName(code[i+1])))
		case 0xA5:
			sb.WriteString(fmt.Sprintf("lda     %s", zpName(code[i+1])))
		case 0xA6:
			sb.WriteString(fmt.Sprintf("ldx     %s", zpName(code[i+1])))
		case 0xC5:
			sb.WriteString(fmt.Sprintf("cmp     %s", zpName(code[i+1])))
		case 0xC6:
			sb.WriteString(fmt.Sprintf("dec     %s", zpName(code[i+1])))
		case 0xE5:
			sb.WriteString(fmt.Sprintf("sbc     %s", zpName(code[i+1])))
		case 0xE6:
			sb.WriteString(fmt.Sprintf("inc     %s", zpName(code[i+1])))

		// Immediate
		case 0x09:
			sb.WriteString(fmt.Sprintf("ora     #$%02X", code[i+1]))
		case 0x49:
			sb.WriteString(fmt.Sprintf("eor     #$%02X", code[i+1]))
		case 0x69:
			sb.WriteString(fmt.Sprintf("adc     #$%02X", code[i+1]))
		case 0xA0:
			sb.WriteString(fmt.Sprintf("ldy     #$%02X", code[i+1]))
		case 0xA2:
			sb.WriteString(fmt.Sprintf("ldx     #$%02X", code[i+1]))
		case 0xA9:
			sb.WriteString(fmt.Sprintf("lda     #$%02X", code[i+1]))
		case 0xC9:
			sb.WriteString(fmt.Sprintf("cmp     #$%02X", code[i+1]))
		case 0xE0:
			sb.WriteString(fmt.Sprintf("cpx     #$%02X", code[i+1]))
		case 0xE9:
			sb.WriteString(fmt.Sprintf("sbc     #$%02X", code[i+1]))

		// Indirect Y
		case 0xB1:
			sb.WriteString(fmt.Sprintf("lda     (%s),y", zpName(code[i+1])))
		case 0x91:
			sb.WriteString(fmt.Sprintf("sta     (%s),y", zpName(code[i+1])))

		// Branches
		case 0x10:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bpl     %s", labelFor(target)))
		case 0x30:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bmi     %s", labelFor(target)))
		case 0x50:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bvc     %s", labelFor(target)))
		case 0x70:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bvs     %s", labelFor(target)))
		case 0x90:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bcc     %s", labelFor(target)))
		case 0xB0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bcs     %s", labelFor(target)))
		case 0xD0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bne     %s", labelFor(target)))
		case 0xF0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("beq     %s", labelFor(target)))

		// Absolute
		case 0x20:
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			sb.WriteString(fmt.Sprintf("jsr     %s", labelFor(target)))
		case 0x2C:
			if isBitSkip {
				sb.WriteString(".byte   $2C     ; BIT abs opcode - skip next 2 bytes")
			} else {
				target := uint16(code[i+1]) | uint16(code[i+2])<<8
				sb.WriteString(fmt.Sprintf("bit     $%04X", target))
			}
		case 0x4C:
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			sb.WriteString(fmt.Sprintf("jmp     %s", labelFor(target)))

		default:
			sb.WriteString(fmt.Sprintf(".byte   $%02X", op))
		}

		sb.WriteString("\n")
		i += size
	}

	sb.WriteString(".endproc\n")
	return sb.String()
}

func opcodeSize(op byte) int {
	// Implied/accumulator
	if op == 0x00 || op == 0x08 || op == 0x18 || op == 0x28 || op == 0x38 || op == 0x48 || op == 0x68 ||
		op == 0x8A || op == 0x98 || op == 0xAA || op == 0xA8 || op == 0xCA || op == 0xE8 || op == 0x0A || op == 0x4A || op == 0x2A || op == 0x6A || op == 0x60 {
		return 1
	}
	// Absolute (JMP, JSR, BIT abs)
	if op == 0x20 || op == 0x4C || op == 0x2C {
		return 3
	}
	// Everything else is 2 bytes
	return 2
}

func isBranch(op byte) bool {
	return op == 0x10 || op == 0x30 || op == 0x50 || op == 0x70 || // BPL, BMI, BVC, BVS
		op == 0x90 || op == 0xB0 || op == 0xD0 || op == 0xF0 // BCC, BCS, BNE, BEQ
}

// GetDecompressorCodeSize returns the size of the machine code
func GetDecompressorCodeSize() int {
	return len(GetDecompressorCode())
}

// PrintDecompressorAsm prints the assembly source to stdout
func PrintDecompressorAsm() {
	fmt.Printf("; Size: %d bytes\n", GetDecompressorCodeSize())
	fmt.Print(GetDecompressorAsm())
}

// WriteDecompressorBin writes the decompressor machine code to a file
func WriteDecompressorBin(path string) error {
	return os.WriteFile(path, GetDecompressorCode(), 0644)
}

// WriteDecompressorAsm writes the decompressor assembly source to a file
func WriteDecompressorAsm(path string) error {
	zpDefs := `; External zero page variables (must be defined by caller)
; zp_src_lo       = $02   ; Source pointer (compressed data)
; zp_src_hi       = $03
; zp_bitbuf       = $04   ; Bit buffer (set to $80 for first call)
; zp_out_lo       = $05   ; Output pointer ($1000 or $7000)
; zp_out_hi       = $06

; Internal zero page variables
zp_val_lo       = $07
zp_val_hi       = $08
zp_ref_lo       = $09
zp_ref_hi       = $0A
zp_other_delta  = $0B
zp_caller_x     = $0C

`
	content := fmt.Sprintf("; Size: %d bytes\n%s%s", GetDecompressorCodeSize(), zpDefs, GetDecompressorAsmInclude())
	return os.WriteFile(path, []byte(content), 0644)
}

// GetDecompressorAsmInclude returns the decompressor as includable assembly (no segment directives)
func GetDecompressorAsmInclude() string {
	full := GetDecompressorAsm()
	// Strip the standalone header (segments, load address) - find ".proc decompress"
	idx := strings.Index(full, ".proc decompress")
	if idx == -1 {
		return full
	}
	return full[idx:]
}

// GetDecompressorCode returns the assembled decompressor (optimized version)
// This is the single source of truth - assembly is generated from this.
// Entry point is at offset 0
func GetDecompressorCode() []byte {
	code, _ := GetDecompressorCodeWithLabels()
	return code
}

// GetDecompressorCodeWithLabels returns the code and a map of label names to offsets
func GetDecompressorCodeWithLabels() ([]byte, map[string]int) {
	code := make([]byte, 0, 350)
	labels := make(map[string]int)

	emit := func(bytes ...byte) int {
		start := len(code)
		code = append(code, bytes...)
		return start
	}

	emitAt := func(pos int, bytes ...byte) {
		for i, b := range bytes {
			code[pos+i] = b
		}
	}

	pos := func() int { return len(code) }

	placeholder := func() int {
		p := pos()
		emit(0x00, 0x00)
		return p
	}

	patch16 := func(at int, addr uint16) {
		emitAt(at, byte(addr), byte(addr>>8))
	}

	patchRel := func(branchPos int, targetPos int) {
		offset := targetPos - branchPos - 2
		emitAt(branchPos+1, byte(offset))
	}

	label := func(name string) int {
		p := pos()
		labels[name] = p
		return p
	}

	base := uint16(0x0D00)

	// ==================== ENTRY ====================
	label("decompress")
	// Entry: zpOutLo/zpOutHi already set to target address
	// Compute zpOtherDelta from zpOutHi (< $70 = odd buffer, >= $70 = even buffer)
	// zpOtherDelta used with SBC (C=1): $A0 gives +$60, $60 gives -$60
	emit(0xA0, 0x00)         // LDY #0 (Y stays 0 throughout)
	emit(0xA5, zpOutHi)      // LDA zpOutHi
	emit(0xC9, 0x70)         // CMP #$70
	emit(0xA9, 0xA0)         // LDA #$A0 (odd buffer delta)
	emit(0x90, 0x02)         // BCC +2 (if < $70, keep $A0)
	emit(0xA9, 0x60)         // LDA #$60 (even buffer delta)
	label("store_delta")
	emit(0x85, zpOtherDelta) // STA zpOtherDelta

	// ==================== MAIN_LOOP ====================
	mainLoopPos := label("main_loop")

	// Dispatch: X holds 3-adj value for backref d*3+(3-adj) calculation
	emit(0xA2, 0x01) // LDX #1 (base for backref adj, modified by INX chain)
	emit(0x20)
	jsrReadBit1 := placeholder()
	bccBackref := pos()
	emit(0x90, 0x00) // BCC set_x3 (backref0: X=1 → INX INX → X=3)

	emit(0x20)
	jsrReadBit2 := placeholder()
	bcsNotLiteral := pos()
	emit(0xB0, 0x00) // BCS @not_literal

	// ==================== LITERAL ====================
	emit(0x8A) // TXA (X=1, sentinel for bit accumulation)
	literalLoopPos := label("literal_loop")
	emit(0x20)
	jsrReadBitLit := placeholder()
	emit(0x2A) // ROL A
	bccLoopOffset := literalLoopPos - pos() - 2
	emit(0x90, byte(bccLoopOffset)) // BCC @loop
	// No terminator check needed - terminator is now backref with dist.hi >= $80
	emit(0x91, zpOutLo) // STA (zpOutLo),Y
	emit(0xE6, zpOutLo) // INC zpOutLo
	bneToMain := pos()
	emit(0xD0, 0x00)    // BNE main_loop
	emit(0xE6, zpOutHi) // INC zpOutHi
	toMainFromLiteral := mainLoopPos - pos() - 2
	emit(0xD0, byte(toMainFromLiteral)) // BNE main_loop (always taken)
	patchRel(bneToMain, mainLoopPos)

	notLiteralPos := label("not_literal")
	patchRel(bcsNotLiteral, notLiteralPos)

	// X=1 already set, no manipulation needed
	emit(0x20)
	jsrReadBit3 := placeholder()
	bccBackref1 := pos()
	emit(0x90, 0x00) // BCC backref_common (backref1: X=1)

	emit(0x20)
	jsrReadBit4 := placeholder()
	bccFwdref := pos()
	emit(0x90, 0x00) // BCC do_fwdref

	emit(0x20)
	jsrReadBit5 := placeholder()
	bccBackref2 := pos()
	emit(0x90, 0x00) // BCC set_x2 (backref2: X=1 → INX → X=2)
	// C=1 means copyother - fall through (saves BCS branch!)

	// ==================== FWDREF/COPYOTHER ====================
	// fwdref: C=0 from BCC, copyother: C=1 from fall-through
	// Save C using PHP, restore with PLP later
	doFwdrefPos := label("fwdref")
	patchRel(bccFwdref, doFwdrefPos)
	emit(0x08) // PHP (save processor status including C)
	emit(0x20)
	jsrExpgol3 := placeholder()
	// Compute zpCopy = dst + dist (A=zpValLo, X=zpValHi, C=0 from read_expgol)
	emit(0x65, zpOutLo)  // ADC zpOutLo
	emit(0x85, zpRefLo) // STA zpRefLo
	emit(0x8A)           // TXA (X=zpValHi from read_expgol)
	emit(0x65, zpOutHi)  // ADC zpOutHi
	emit(0x28)           // PLP (restore C: 0 for fwdref, 1 for copyother)
	bccStoreAndCheck := pos()
	emit(0x90, 0x00) // BCC @store_and_check (fwdref)
	// Copyother: SBC zpOtherDelta (C=1 from PLP) to reach other buffer
	emit(0xE5, zpOtherDelta) // SBC zpOtherDelta ($A0→+$60, $60→-$60)

	storeAndCheckPos := label("store_and_check")
	patchRel(bccStoreAndCheck, storeAndCheckPos)
	emit(0xC9, 0xD0) // CMP #$D0
	bccNoHighWrap := pos()
	emit(0x90, 0x00) // BCC @no_high_wrap
	emit(0xE9, 0xC0) // SBC #$C0
	noHighWrapPos := label("no_high_wrap")
	patchRel(bccNoHighWrap, noHighWrapPos)
	bneFwdrefToCopy := pos()
	emit(0xD0, 0x00) // BNE store_copy_hi (always taken)

	// ==================== BACKREF ====================
	// X adjustment via fall-through INX chain (saves 1 byte vs DEX DEX INX)
	setX3Pos := label("set_x3")
	patchRel(bccBackref, setX3Pos) // backref0 enters here: X=1 → 2 → 3
	emit(0xE8) // INX
	setX2Pos := label("set_x2")
	patchRel(bccBackref2, setX2Pos) // backref2 enters here: X=1 → 2
	emit(0xE8) // INX
	backrefCommonPos := label("backref_common")
	patchRel(bccBackref1, backrefCommonPos) // backref1 enters here: X=1

	// X contains adj (1,2,3) - read_expgol will STX zpCallerX at start
	emit(0x20)
	jsrExpgol1 := placeholder()
	// Compute d*3+adj: all lo ops first, then all hi ops
	// Lo: 2*lo -> 2*lo+adj -> 3*lo+adj, saving carries on stack
	emit(0x0A)          // ASL A (A=2*lo, C=carry_a)
	emit(0x08)          // PHP (save carry_a)
	emit(0x18)          // CLC
	emit(0x65, zpCallerX) // ADC zpCallerX (A=2*lo+adj, C=carry_b)
	emit(0x08)          // PHP (save carry_b)
	emit(0x18)          // CLC
	emit(0x65, zpValLo) // ADC zpValLo (A=3*lo+adj, C=carry_c)
	emit(0x85, zpValLo) // STA zpValLo (final lo)
	// Hi: 3*hi + carry_a + carry_b + carry_c
	emit(0x8A)          // TXA (X=zpValHi from read_expgol, C=carry_c preserved)
	emit(0x2A)           // ROL A (A=2*hi+carry_c, C=0 since hi<128)
	emit(0x28)           // PLP (C=carry_b)
	emit(0x65, zpValHi) // ADC zpValHi (A=3*hi+carry_b+carry_c)
	emit(0x28)           // PLP (C=carry_a)
	emit(0x69, 0x00)    // ADC #0 (A=3*hi+all carries)
	emit(0x85, zpValHi) // STA zpValHi
	label("compute_copy_src")
	// Compute copy source = dst - dist
	// When dist > dst, result is negative and needs adjustment to reach otherDict
	emit(0xA5, zpOutLo) // LDA zpOutLo
	emit(0x38)          // SEC
	emit(0xE5, zpValLo) // SBC zpValLo
	emit(0x85, zpRefLo) // STA zpRefLo
	emit(0xA5, zpOutHi)  // LDA zpOutHi
	emit(0xE5, zpValHi) // SBC zpValHi
	bccNeedAdjust := pos()
	emit(0x90, 0x00) // BCC need_adjust (borrow means dist > dst)
	emit(0xC9, 0x10) // CMP #$10
	bcsNoAdjust := pos()
	emit(0xB0, 0x00) // BCS no_adjust (address >= $1000 is valid)
	needAdjustPos := label("backref_adjust")
	patchRel(bccNeedAdjust, needAdjustPos)
	emit(0x69, 0xC0) // ADC #$C0 (convert to otherDict address, C=0)
	noAdjustPos := label("backref_no_adjust")
	patchRel(bcsNoAdjust, noAdjustPos)
	// Falls through to store_copy_hi

	// ==================== STORE_COPY_HI (shared) ====================
	storeCopyHiPos := label("store_copy_hi")
	patchRel(bneFwdrefToCopy, storeCopyHiPos)
	emit(0x85, zpRefHi) // STA zpRefHi (shared by fwdref and backref)

	// ==================== COPY_WITH_LENGTH ====================
	label("copy_with_length")
	emit(0x20)
	jsrExpgolLen2 := placeholder()
	// Add 2 to length (A=zpValLo, C=0 from read_expgol)
	emit(0x69, 0x02) // ADC #2
	emit(0xAA)           // TAX (low counter in X)
	emit(0x90, 0x02)     // BCC +2
	emit(0xE6, zpValHi) // INC zpValHi

	// ==================== COPY_LOOP ====================
	label("copy_loop")
	copyLoopInnerPos := pos()
	emit(0xB1, zpRefLo) // LDA (zpRefLo),Y
	emit(0x91, zpOutLo)  // STA (zpOutLo),Y
	emit(0xE6, zpOutLo)  // INC zpOutLo
	emit(0xD0, 0x02)     // BNE +2
	emit(0xE6, zpOutHi)  // INC zpOutHi
	label("skip_out_hi_inc")
	emit(0xE6, zpRefLo) // INC zpRefLo
	emit(0xD0, 0x02)     // BNE +2
	emit(0xE6, zpRefHi) // INC zpRefHi
	label("skip_ref_hi_inc")
	// Decrement counter with early exit (X = low byte)
	emit(0x8A) // TXA (check X before decrement, sets Z)
	bneNoBorrow := pos()
	emit(0xD0, 0x02)     // BNE +2 (no borrow needed)
	emit(0xC6, zpValHi) // DEC zpValHi (borrow)
	patchRel(bneNoBorrow, pos())
	label("skip_val_hi_dec")
	emit(0xCA)          // DEX
	emit(0x8A)          // TXA (get decremented X into A)
	emit(0x05, zpValHi) // ORA zpValHi (A=0 only if both X and zpValHi are 0)
	bneCopyLoop := copyLoopInnerPos - pos() - 2
	emit(0xD0, byte(bneCopyLoop)) // BNE copy_loop (continue if counter != 0)
	emit(0x4C)                    // JMP main_loop (done)
	jmpMainFromCopy := placeholder()
	patch16(jmpMainFromCopy, base+uint16(mainLoopPos))

	// ==================== READ_EXPGOL ====================
	readExpgolPos := label("read_expgol")
	patch16(jsrExpgol1, base+uint16(readExpgolPos))
	patch16(jsrExpgol3, base+uint16(readExpgolPos))
	patch16(jsrExpgolLen2, base+uint16(readExpgolPos))

	// Store caller's X - backref uses this for adjustment value
	emit(0x86, zpCallerX) // STX zpCallerX

	// Count leading zeros using X (inverted: count down, then INX in read loop)
	emit(0xA2, 0x01)     // LDX #$01
	emit(0x86, zpValLo) // STX zpValLo
	emit(0x84, zpValHi) // STY zpValHi (Y=0)
	countZerosPos := label("count_zeros")
	emit(0xCA)                        // DEX
	emit(0xE0, terminatorThreshold)   // CPX #(256-TERMINATOR_ZEROS)
	bccTerminatorEarly := pos()
	emit(0xF0, 0x00)    // BEQ terminator (TERMINATOR_ZEROS zeros = terminator)
	label("do_read")
	emit(0x20)
	jsrReadBitGamma := placeholder()
	bccCountZeros := countZerosPos - pos() - 2
	emit(0x90, byte(bccCountZeros)) // BCC @count_zeros
	// X = $00 for 0 zeros, $FF..$F5 for 1-11 zeros (12+ handled above)
	emit(0x8A) // TXA (sets Z flag)
	beqGammaDone := pos()
	emit(0xF0, 0x00) // BEQ @gamma_done (0 zeros = valid)

	readBitsLoopPos := label("read_gamma_bits")
	emit(0x20)
	jsrReadBitGamma2 := placeholder()
	emit(0x26, zpValLo) // ROL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	emit(0xE8)           // INX
	bneReadBits := readBitsLoopPos - pos() - 2
	emit(0xD0, byte(bneReadBits)) // BNE @read_bits

	gammaDonePos := label("gamma_done")
	patchRel(beqGammaDone, gammaDonePos)

	// Decrement gamma by 1
	emit(0xA5, zpValLo) // LDA zpValLo
	bneNoGammaBorrow := pos()
	emit(0xD0, 0x00)     // BNE +2
	emit(0xC6, zpValHi) // DEC zpValHi
	noGammaBorrowPos := label("dec_gamma")
	patchRel(bneNoGammaBorrow, noGammaBorrowPos)
	emit(0xC6, zpValLo) // DEC zpValLo

	// Shift left by 2: (gamma-1)*4
	emit(0x06, zpValLo) // ASL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	emit(0x06, zpValLo) // ASL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	// Read 2 suffix bits
	emit(0x98)           // TYA (A=0)
	emit(0x20)
	jsrReadBitExp1 := placeholder()
	emit(0x2A) // ROL A
	emit(0x20)
	jsrReadBitExp2 := placeholder()
	emit(0x2A)           // ROL A (C=0: A is at most 3, bit 7 always 0)
	emit(0x05, zpValLo) // ORA zpValLo
	emit(0x85, zpValLo) // STA zpValLo
	emit(0xA6, zpValHi) // LDX zpValHi (return hi byte in X for callers)
	emit(0x60)           // RTS

	// ==================== READ_BIT (moved to end) ====================
	readBitPos := label("read_bit")
	patch16(jsrReadBit1, base+uint16(readBitPos))
	patch16(jsrReadBit2, base+uint16(readBitPos))
	patch16(jsrReadBitLit, base+uint16(readBitPos))
	patch16(jsrReadBit3, base+uint16(readBitPos))
	patch16(jsrReadBit4, base+uint16(readBitPos))
	patch16(jsrReadBit5, base+uint16(readBitPos))
	patch16(jsrReadBitGamma, base+uint16(readBitPos))
	patch16(jsrReadBitGamma2, base+uint16(readBitPos))
	patch16(jsrReadBitExp1, base+uint16(readBitPos))
	patch16(jsrReadBitExp2, base+uint16(readBitPos))

	emit(0x06, zpBitBuf) // ASL zpBitBuf
	bneReadBitDone := pos()
	emit(0xD0, 0x00)     // BNE @done
	emit(0x48)           // PHA (save original A)
	emit(0xB1, zpSrcLo)  // LDA (zpSrcLo),Y
	emit(0x2A)           // ROL A (C=1 from sentinel shift-out)
	emit(0x85, zpBitBuf) // STA zpBitBuf
	emit(0xE6, zpSrcLo)  // INC zpSrcLo
	bneSkipSrcHiInc := pos()
	emit(0xD0, 0x00)     // BNE skip_src_hi_inc (no page cross)
	emit(0xE6, zpSrcHi)  // INC zpSrcHi (let it wrap naturally to $00)
	skipSrcHiIncPos := label("skip_src_hi_inc")
	patchRel(bneSkipSrcHiInc, skipSrcHiIncPos)
	emit(0x48) // PHA (push again for shared PLA PLA sequence)

	// ==================== TERMINATOR EXIT ====================
	// Shared exit: normal path pops [temp][orig_A], terminator pops [ret_lo][ret_hi]
	terminatorPos := label("terminator")
	patchRel(bccTerminatorEarly, terminatorPos)
	emit(0x68) // PLA
	emit(0x68) // PLA
	readBitDonePos := label("read_bit_done")
	patchRel(bneReadBitDone, readBitDonePos)
	emit(0x60) // RTS

	return code, labels
}
