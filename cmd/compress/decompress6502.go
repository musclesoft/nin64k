package main

import (
	"fmt"
	"os"
	"sort"
	"strings"
)

// 6502 Decompressor for V23 encoding
// All addresses are calculated dynamically - no hardcoded offsets

// Zero page layout
const (
	zpSrcLo      = 0x02 // Source pointer (compressed data)
	zpSrcHi      = 0x03
	zpBitBuf     = 0x04 // Current byte being read
	zpOutLo      = 0x05 // Output pointer
	zpOutHi      = 0x06
	zpValLo      = 0x07 // Multi-purpose: exp-golomb value, distance, length counter
	zpValHi      = 0x08
	zpRefLo      = 0x09 // Reference pointer (copy source)
	zpRefHi      = 0x0A
	zpOtherDelta = 0x0B // Delta to reach other buffer: (otherBase - selfBase) >> 8
	zpCallerX    = 0x0C // Caller's X saved by read_expgol (backref uses for adj 1/2/3)
)

// Buffer layout constants for dual-buffer decompression
// Buffer 1 (odd songs): $2000-$3FFF
// Buffer 2 (even songs): $4000-$5FFF
// Gap between buffers: $2000
//
// To change buffer addresses:
//   1. Update these constants
//   2. Update TUNE1_BASE/TUNE2_BASE in: nin64k.asm, nin64sid.asm, nin64selftest.asm
//   3. Update PART1 segment start in: c64.cfg, sid.cfg
//   4. Run: go run ./cmd/compress && make clean && make
const (
	DecompBuf1Hi  = 0x20 // Buffer 1 high byte ($2000)
	DecompBuf2Hi  = 0x40 // Buffer 2 high byte ($4000)
	DecompBufGap  = 0x20 // Gap between buffers ($2000 >> 8)
	DecompWrapHi  = 0x60 // Buffer 2 + gap ($4000 + $2000 = $6000)
	DecompWrapAdj = DecompWrapHi - DecompBuf1Hi // $40 = wrap adjustment
)

// Terminator detection: must be > max gamma zeros in compressed data
// X counts down from 1: after N zeros, X = 1-(N+1) = -N (mod 256)
// Threshold = 256 - terminatorZeros detects exactly terminatorZeros consecutive zeros
const (
	TerminatorZeros     = 12   // number of zero bits that signal terminator
	terminatorThreshold = 256 - TerminatorZeros // $F4 for 12 zeros
)

// zpName returns the symbolic name for a zero page address
func zpName(addr byte) string {
	names := map[byte]string{
		0x02: "zp_src_lo", 0x03: "zp_src_hi",
		0x04: "zp_bitbuf",
		0x05: "zp_out_lo", 0x06: "zp_out_hi",
		0x07: "zp_val_lo", 0x08: "zp_val_hi",
		0x09: "zp_ref_lo", 0x0A: "zp_ref_hi",
		0x0B: "zp_other_delta", 0x0C: "zp_caller_x",
	}
	if name, ok := names[addr]; ok {
		return name
	}
	return fmt.Sprintf("$%02X", addr)
}

// GetDecompressorAsm returns the decompressor as ca65 assembly source code
// Generated by disassembling GetDecompressorCode()
func GetDecompressorAsm() string {
	return GetDecompressorAsmWithCycleStats(-1, 0)
}

// GetDecompressorAsmWithCycleStats returns the decompressor as ca65 assembly source code
// with a comment on the instruction with lowest max cycle gap between revisits
func GetDecompressorAsmWithCycleStats(lowestMaxGapOffset int, maxCycleGap uint64) string {
	code, labelMap := GetDecompressorCodeWithLabels()
	base := uint16(0x0D00)

	// Create reverse map: address -> label name
	// Sort label names for deterministic output when multiple labels share an address
	labelNames := make(map[uint16]string)
	var sortedNames []string
	for name := range labelMap {
		sortedNames = append(sortedNames, name)
	}
	sort.Strings(sortedNames)
	for _, name := range sortedNames {
		offset := labelMap[name]
		addr := base + uint16(offset)
		if _, exists := labelNames[addr]; !exists {
			labelNames[addr] = name
		}
	}

	// Helper to get label name for an address
	labelFor := func(addr uint16) string {
		if name, ok := labelNames[addr]; ok {
			return name
		}
		return fmt.Sprintf("L%04X", addr)
	}

	var sb strings.Builder
	// Get checkpoint offset for skipping in output
	checkpointOffset := -1
	if off, ok := labelMap["checkpoint"]; ok {
		checkpointOffset = off
	}

	sb.WriteString(`; ============================================================================
; V23 Decompressor for 6502 - Generated from machine code
; ============================================================================
;
; Load address: $0D00
; Entry point:  decompress
;
; IMPORTANT: You must define 'checkpoint' globally before including this file.
; The decompressor calls checkpoint frequently (every bit read, every byte copied).
; Checkpoint can trash A and P. Minimal implementation: checkpoint: rts
;
; Setup required before calling:
;   $02-$03 (zp_src)    - Source pointer to compressed data
;   $04     (zp_bitbuf) - Bit buffer (set to $80 for first call)
;   $05-$06 (zp_out)    - Output pointer ($1000 or $7000)
;
; On return:
;   $02-$03 (zp_src)    - Updated source pointer
;   $04     (zp_bitbuf) - Updated bit buffer (pass to next call)
; ============================================================================

.setcpu "6502"

.segment "LOADADDR"
        .word   $0D00

.segment "CODE"

.proc decompress
`)

	// Collect branch targets for labels
	targets := make(map[uint16]bool)
	for i := 0; i < len(code); {
		op := code[i]
		size := opcodeSize(op)
		if size == 2 && isBranch(op) {
			offset := int8(code[i+1])
			target := uint16(int(base) + i + 2 + int(offset))
			targets[target] = true
		}
		if size == 3 && (op == 0x4C || op == 0x20) { // JMP/JSR
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			if target >= base && target < base+uint16(len(code)) {
				targets[target] = true
			}
		}
		i += size
	}

	// Disassemble
	for i := 0; i < len(code); {
		addr := base + uint16(i)

		// Skip checkpoint - it's defined externally
		if i == checkpointOffset {
			i += opcodeSize(code[i])
			continue
		}

		// Label if this is a branch target (but not checkpoint)
		if targets[addr] {
			lbl := labelFor(addr)
			if lbl != "checkpoint" {
				sb.WriteString(fmt.Sprintf("%s:\n", lbl))
			}
		}

		op := code[i]
		size := opcodeSize(op)

		// Detect BIT abs skip trick: $2C followed by branch target at +1
		isBitSkip := op == 0x2C && i+1 < len(code) && targets[base+uint16(i+1)]
		if isBitSkip {
			size = 1 // Treat as single byte so hidden instruction is decoded
		}

		sb.WriteString(fmt.Sprintf("        "))

		switch op {
		// Implied
		case 0x00:
			sb.WriteString("brk")
		case 0x08:
			sb.WriteString("php")
		case 0x18:
			sb.WriteString("clc")
		case 0x38:
			sb.WriteString("sec")
		case 0x48:
			sb.WriteString("pha")
		case 0x28:
			sb.WriteString("plp")
		case 0x68:
			sb.WriteString("pla")
		case 0x8A:
			sb.WriteString("txa")
		case 0xCA:
			sb.WriteString("dex")
		case 0xE8:
			sb.WriteString("inx")
		case 0x98:
			sb.WriteString("tya")
		case 0xAA:
			sb.WriteString("tax")
		case 0xA8:
			sb.WriteString("tay")
		case 0x0A:
			sb.WriteString("asl a")
		case 0x4A:
			sb.WriteString("lsr a")
		case 0x2A:
			sb.WriteString("rol a")
		case 0x6A:
			sb.WriteString("ror a")
		case 0x60:
			sb.WriteString("rts")

		// Zero page
		case 0x05:
			sb.WriteString(fmt.Sprintf("ora     %s", zpName(code[i+1])))
		case 0x06:
			sb.WriteString(fmt.Sprintf("asl     %s", zpName(code[i+1])))
		case 0x26:
			sb.WriteString(fmt.Sprintf("rol     %s", zpName(code[i+1])))
		case 0x65:
			sb.WriteString(fmt.Sprintf("adc     %s", zpName(code[i+1])))
		case 0x84:
			sb.WriteString(fmt.Sprintf("sty     %s", zpName(code[i+1])))
		case 0x85:
			sb.WriteString(fmt.Sprintf("sta     %s", zpName(code[i+1])))
		case 0x86:
			sb.WriteString(fmt.Sprintf("stx     %s", zpName(code[i+1])))
		case 0xA5:
			sb.WriteString(fmt.Sprintf("lda     %s", zpName(code[i+1])))
		case 0xA6:
			sb.WriteString(fmt.Sprintf("ldx     %s", zpName(code[i+1])))
		case 0xC5:
			sb.WriteString(fmt.Sprintf("cmp     %s", zpName(code[i+1])))
		case 0xC6:
			sb.WriteString(fmt.Sprintf("dec     %s", zpName(code[i+1])))
		case 0xE5:
			sb.WriteString(fmt.Sprintf("sbc     %s", zpName(code[i+1])))
		case 0xE6:
			sb.WriteString(fmt.Sprintf("inc     %s", zpName(code[i+1])))

		// Immediate
		case 0x09:
			sb.WriteString(fmt.Sprintf("ora     #$%02X", code[i+1]))
		case 0x49:
			sb.WriteString(fmt.Sprintf("eor     #$%02X", code[i+1]))
		case 0x69:
			sb.WriteString(fmt.Sprintf("adc     #$%02X", code[i+1]))
		case 0xA0:
			sb.WriteString(fmt.Sprintf("ldy     #$%02X", code[i+1]))
		case 0xA2:
			sb.WriteString(fmt.Sprintf("ldx     #$%02X", code[i+1]))
		case 0xA9:
			sb.WriteString(fmt.Sprintf("lda     #$%02X", code[i+1]))
		case 0xC9:
			sb.WriteString(fmt.Sprintf("cmp     #$%02X", code[i+1]))
		case 0xE0:
			sb.WriteString(fmt.Sprintf("cpx     #$%02X", code[i+1]))
		case 0xE9:
			sb.WriteString(fmt.Sprintf("sbc     #$%02X", code[i+1]))

		// Indirect Y
		case 0xB1:
			sb.WriteString(fmt.Sprintf("lda     (%s),y", zpName(code[i+1])))
		case 0x91:
			sb.WriteString(fmt.Sprintf("sta     (%s),y", zpName(code[i+1])))

		// Branches
		case 0x10:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bpl     %s", labelFor(target)))
		case 0x30:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bmi     %s", labelFor(target)))
		case 0x50:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bvc     %s", labelFor(target)))
		case 0x70:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bvs     %s", labelFor(target)))
		case 0x90:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bcc     %s", labelFor(target)))
		case 0xB0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bcs     %s", labelFor(target)))
		case 0xD0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("bne     %s", labelFor(target)))
		case 0xF0:
			target := uint16(int(addr) + 2 + int(int8(code[i+1])))
			sb.WriteString(fmt.Sprintf("beq     %s", labelFor(target)))

		// Absolute
		case 0x20:
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			sb.WriteString(fmt.Sprintf("jsr     %s", labelFor(target)))
		case 0x2C:
			if isBitSkip {
				sb.WriteString(".byte   $2C     ; BIT abs opcode - skip next 2 bytes")
			} else {
				target := uint16(code[i+1]) | uint16(code[i+2])<<8
				sb.WriteString(fmt.Sprintf("bit     $%04X", target))
			}
		case 0x4C:
			target := uint16(code[i+1]) | uint16(code[i+2])<<8
			sb.WriteString(fmt.Sprintf("jmp     %s", labelFor(target)))

		default:
			sb.WriteString(fmt.Sprintf(".byte   $%02X", op))
		}

		// Add comment for lowest max cycle gap instruction
		if i == lowestMaxGapOffset && maxCycleGap > 0 {
			sb.WriteString(fmt.Sprintf(" ; lowest max cycle gap (%d cycles)", maxCycleGap))
		}

		sb.WriteString("\n")
		i += size
	}

	// Add cycle stats comment at end if checkpoint was skipped
	if maxCycleGap > 0 && lowestMaxGapOffset == checkpointOffset {
		sb.WriteString(fmt.Sprintf("; checkpoint: max %d cycles between calls\n", maxCycleGap))
	}
	sb.WriteString(".endproc\n")
	return sb.String()
}

func opcodeSize(op byte) int {
	// Implied/accumulator
	if op == 0x00 || op == 0x08 || op == 0x18 || op == 0x28 || op == 0x38 || op == 0x48 || op == 0x68 ||
		op == 0x8A || op == 0x98 || op == 0xAA || op == 0xA8 || op == 0xCA || op == 0xE8 || op == 0x0A || op == 0x4A || op == 0x2A || op == 0x6A || op == 0x60 {
		return 1
	}
	// Absolute (JMP, JSR, BIT abs)
	if op == 0x20 || op == 0x4C || op == 0x2C {
		return 3
	}
	// Everything else is 2 bytes
	return 2
}

func isBranch(op byte) bool {
	return op == 0x10 || op == 0x30 || op == 0x50 || op == 0x70 || // BPL, BMI, BVC, BVS
		op == 0x90 || op == 0xB0 || op == 0xD0 || op == 0xF0 // BCC, BCS, BNE, BEQ
}

// GetDecompressorCodeSize returns the size of the machine code
func GetDecompressorCodeSize() int {
	return len(GetDecompressorCode())
}

// WriteDecompressorBin writes the decompressor machine code to a file
func WriteDecompressorBin(path string) error {
	return os.WriteFile(path, GetDecompressorCode(), 0644)
}

// WriteDecompressorAsm writes the decompressor assembly source to a file
func WriteDecompressorAsm(path string) error {
	return WriteDecompressorAsmWithCycleStats(path, -1, 0)
}

// WriteDecompressorAsmWithCycleStats writes the decompressor assembly with cycle stats
func WriteDecompressorAsmWithCycleStats(path string, lowestMaxGapOffset int, maxCycleGap uint64) error {
	zpDefs := fmt.Sprintf(`; External zero page variables (must be defined by caller)
; zp_src_lo       = $02   ; Source pointer (compressed data)
; zp_src_hi       = $03
; zp_bitbuf       = $04   ; Bit buffer (set to $80 for first call)
; zp_out_lo       = $05   ; Output pointer
; zp_out_hi       = $06
;
; IMPORTANT: Define 'checkpoint' globally before including this file.
; Called frequently (every bit, every byte). Can trash A and P.
; Minimal: checkpoint: rts

; Buffer layout constants (dual-buffer decompression)
; Buffer 1 (odd songs):  $%02X00
; Buffer 2 (even songs): $%02X00
; To change: update constants in cmd/compress/decompress6502.go, then rebuild
DECOMP_BUF1_HI   = $%02X           ; Buffer 1 high byte
DECOMP_BUF2_HI   = $%02X           ; Buffer 2 high byte
DECOMP_BUF_GAP   = $%02X           ; Gap between buffers ($2000 >> 8)
DECOMP_WRAP_HI   = $%02X           ; Buffer 2 + gap (wrap threshold)

; Internal zero page variables
zp_val_lo       = $07
zp_val_hi       = $08
zp_ref_lo       = $09
zp_ref_hi       = $0A
zp_other_delta  = $0B
zp_caller_x     = $0C

`, DecompBuf1Hi, DecompBuf2Hi, DecompBuf1Hi, DecompBuf2Hi, DecompBufGap, DecompWrapHi)
	// Size excludes checkpoint RTS (1 byte) which is defined externally
	content := fmt.Sprintf("; Generated file - do not edit. Modify cmd/compress/decompress6502.go instead.\n; Size: %d bytes\n%s%s", GetDecompressorCodeSize()-1, zpDefs, GetDecompressorAsmIncludeWithCycleStats(lowestMaxGapOffset, maxCycleGap))
	return os.WriteFile(path, []byte(content), 0644)
}

// GetDecompressorAsmInclude returns the decompressor as includable assembly (no segment directives)
func GetDecompressorAsmInclude() string {
	return GetDecompressorAsmIncludeWithCycleStats(-1, 0)
}

// GetDecompressorAsmIncludeWithCycleStats returns the decompressor as includable assembly with cycle stats
func GetDecompressorAsmIncludeWithCycleStats(lowestMaxGapOffset int, maxCycleGap uint64) string {
	full := GetDecompressorAsmWithCycleStats(lowestMaxGapOffset, maxCycleGap)
	// Strip the standalone header (segments, load address) - find ".proc decompress"
	idx := strings.Index(full, ".proc decompress")
	if idx == -1 {
		return full
	}
	return full[idx:]
}

// GetDecompressorCode returns the assembled decompressor (optimized version)
// This is the single source of truth - assembly is generated from this.
// Entry point is at offset 0
func GetDecompressorCode() []byte {
	code, _ := GetDecompressorCodeWithLabels()
	return code
}

// GetDecompressorCodeWithLabels returns the code and a map of label names to offsets
func GetDecompressorCodeWithLabels() ([]byte, map[string]int) {
	code := make([]byte, 0, 350)
	labels := make(map[string]int)

	emit := func(bytes ...byte) int {
		start := len(code)
		code = append(code, bytes...)
		return start
	}

	emitAt := func(pos int, bytes ...byte) {
		for i, b := range bytes {
			code[pos+i] = b
		}
	}

	pos := func() int { return len(code) }

	placeholder := func() int {
		p := pos()
		emit(0x00, 0x00)
		return p
	}

	patch16 := func(at int, addr uint16) {
		emitAt(at, byte(addr), byte(addr>>8))
	}

	patchRel := func(branchPos int, targetPos int) {
		offset := targetPos - branchPos - 2
		emitAt(branchPos+1, byte(offset))
	}

	label := func(name string) int {
		p := pos()
		labels[name] = p
		return p
	}

	base := uint16(0x0D00)

	// ==================== ENTRY ====================
	label("decompress")
	// Entry: zpOutLo/zpOutHi already set to target address
	// Compute zpOtherDelta from zpOutHi to determine which buffer we're in
	// zpOtherDelta used with SBC (C=1): -gap gives +gap, +gap gives -gap
	emit(0xA0, 0x00)             // LDY #0 (Y stays 0 throughout)
	emit(0xA5, zpOutHi)          // LDA zpOutHi
	emit(0xC9, DecompBuf2Hi)     // CMP #DecompBuf2Hi ($70)
	emit(0xA9, 0x100-DecompBufGap) // LDA #$B0 (buffer 1 delta: -$50 = $B0)
	emit(0x90, 0x02)             // BCC +2 (if < buf2, keep $B0)
	emit(0xA9, DecompBufGap)     // LDA #$50 (buffer 2 delta: +$50)
	label("store_delta")
	emit(0x85, zpOtherDelta) // STA zpOtherDelta

	// ==================== MAIN_LOOP ====================
	mainLoopPos := label("main_loop")

	// Dispatch: X holds adj value for backref d*3+adj calculation
	// New prefix order: literal=0, backref0=10, backref1=110, backref2=1110, fwdref=11110, copyother=11111
	emit(0xA2, 0x01) // LDX #1 (base for backref adj and literal sentinel)
	emit(0x20)
	jsrReadBit1 := placeholder()
	bcsNotLiteral := pos()
	emit(0xB0, 0x00) // BCS not_literal (skip if bit=1)

	// ==================== LITERAL (0) - fall through ====================
	label("literal")
	emit(0x8A) // TXA (X=1, sentinel for bit accumulation)
	literalLoopPos := label("literal_loop")
	emit(0x20)
	jsrReadBitLit := placeholder()
	emit(0x2A) // ROL A
	bccLoopOffset := literalLoopPos - pos() - 2
	emit(0x90, byte(bccLoopOffset)) // BCC @loop
	emit(0x91, zpOutLo) // STA (zpOutLo),Y
	emit(0xE6, zpOutLo) // INC zpOutLo
	bneToMainLit := pos()
	emit(0xD0, 0x00)    // BNE main_loop
	emit(0xE6, zpOutHi) // INC zpOutHi
	toMainFromLit := mainLoopPos - pos() - 2
	emit(0xD0, byte(toMainFromLit)) // BNE main_loop (always taken)
	patchRel(bneToMainLit, mainLoopPos)

	// Continue dispatch for non-literal commands
	notLiteralPos := label("not_literal")
	patchRel(bcsNotLiteral, notLiteralPos)

	emit(0x20)
	jsrReadBit2 := placeholder()
	bccBackref0 := pos()
	emit(0x90, 0x00) // BCC set_x3 (10 -> backref0: X=1 → INX INX → X=3)

	emit(0x20)
	jsrReadBit3 := placeholder()
	bccBackref1 := pos()
	emit(0x90, 0x00) // BCC backref_common (110 -> backref1: X=1)

	emit(0x20)
	jsrReadBit4 := placeholder()
	bccBackref2 := pos()
	emit(0x90, 0x00) // BCC set_x2 (1110 -> backref2: X=1 → INX → X=2)

	emit(0x20)
	jsrReadBit5 := placeholder()
	bccFwdref := pos()
	emit(0x90, 0x00) // BCC do_fwdref (11110 -> fwdref)
	// C=1 means copyother (11111) - fall through to fwdref/copyother handler

	// ==================== FWDREF/COPYOTHER ====================
	// fwdref: C=0 from BCC, copyother: C=1 from fall-through
	// Save C using PHP, restore with PLP later
	doFwdrefPos := label("fwdref")
	patchRel(bccFwdref, doFwdrefPos)
	emit(0x08) // PHP (save processor status including C)
	emit(0x20)
	jsrExpgol3 := placeholder()
	// Compute zpCopy = dst + dist (A=zpValLo, X=zpValHi, C=0 from read_expgol)
	emit(0x65, zpOutLo)  // ADC zpOutLo
	emit(0x85, zpRefLo) // STA zpRefLo
	emit(0x8A)           // TXA (X=zpValHi from read_expgol)
	emit(0x65, zpOutHi)  // ADC zpOutHi
	emit(0x28)           // PLP (restore C: 0 for fwdref, 1 for copyother)
	bccStoreAndCheck := pos()
	emit(0x90, 0x00) // BCC @store_and_check (fwdref)
	// Copyother: SBC zpOtherDelta (C=1 from PLP) to reach other buffer
	emit(0xE5, zpOtherDelta) // SBC zpOtherDelta ($A0→+$60, $60→-$60)

	storeAndCheckPos := label("store_and_check")
	patchRel(bccStoreAndCheck, storeAndCheckPos)
	emit(0xC9, DecompWrapHi) // CMP #DecompWrapHi ($C0)
	bccNoHighWrap := pos()
	emit(0x90, 0x00) // BCC @no_high_wrap
	emit(0xE9, DecompWrapAdj) // SBC #DecompWrapAdj ($A0)
	noHighWrapPos := label("no_high_wrap")
	patchRel(bccNoHighWrap, noHighWrapPos)
	bneFwdrefToCopy := pos()
	emit(0xD0, 0x00) // BNE backref_no_adjust (always taken)

	// ==================== BACKREF ====================
	// X adjustment via fall-through INX chain (saves 1 byte vs DEX DEX INX)
	setX3Pos := label("set_x3")
	patchRel(bccBackref0, setX3Pos) // backref0 enters here: X=1 → 2 → 3
	emit(0xE8) // INX
	setX2Pos := label("set_x2")
	patchRel(bccBackref2, setX2Pos) // backref2 enters here: X=1 → 2
	emit(0xE8) // INX
	backrefCommonPos := label("backref_common")
	patchRel(bccBackref1, backrefCommonPos) // backref1 enters here: X=1

	// X contains adj (1,2,3) - read_expgol will STX zpCallerX at start
	emit(0x20)
	jsrExpgol1 := placeholder()
	// Compute d*3+adj: all lo ops first, then all hi ops
	// Lo: 2*lo -> 2*lo+adj -> 3*lo+adj, saving carries on stack
	emit(0x0A)          // ASL A (A=2*lo, C=carry_a)
	emit(0x08)          // PHP (save carry_a)
	emit(0x18)          // CLC
	emit(0x65, zpCallerX) // ADC zpCallerX (A=2*lo+adj, C=carry_b)
	emit(0x08)          // PHP (save carry_b)
	emit(0x18)          // CLC
	emit(0x65, zpValLo) // ADC zpValLo (A=3*lo+adj, C=carry_c)
	emit(0x85, zpValLo) // STA zpValLo (final lo)
	// Hi: 3*hi + carry_a + carry_b + carry_c
	emit(0x8A)          // TXA (X=zpValHi from read_expgol, C=carry_c preserved)
	emit(0x2A)           // ROL A (A=2*hi+carry_c, C=0 since hi<128)
	emit(0x28)           // PLP (C=carry_b)
	emit(0x65, zpValHi) // ADC zpValHi (A=3*hi+carry_b+carry_c)
	emit(0x28)           // PLP (C=carry_a)
	emit(0x69, 0x00)    // ADC #0 (A=3*hi+all carries)
	emit(0x85, zpValHi) // STA zpValHi
	label("compute_copy_src")
	// Compute copy source = dst - dist
	// When dist > dst, result is negative and needs adjustment to reach otherDict
	emit(0xA5, zpOutLo) // LDA zpOutLo
	emit(0x38)          // SEC
	emit(0xE5, zpValLo) // SBC zpValLo
	emit(0x85, zpRefLo) // STA zpRefLo
	emit(0xA5, zpOutHi)  // LDA zpOutHi
	emit(0xE5, zpValHi) // SBC zpValHi
	bccNeedAdjust := pos()
	emit(0x90, 0x00) // BCC need_adjust (borrow means dist > dst)
	emit(0xC9, DecompBuf1Hi) // CMP #DecompBuf1Hi ($20)
	bcsNoAdjust := pos()
	emit(0xB0, 0x00) // BCS no_adjust (address >= buf1 is valid)
	needAdjustPos := label("backref_adjust")
	patchRel(bccNeedAdjust, needAdjustPos)
	emit(0x69, DecompWrapAdj) // ADC #DecompWrapAdj ($A0, wrap by span)
	backrefNoAdjustPos := label("backref_no_adjust")
	patchRel(bcsNoAdjust, backrefNoAdjustPos)
	patchRel(bneFwdrefToCopy, backrefNoAdjustPos)
	emit(0x85, zpRefHi) // STA zpRefHi (shared by fwdref and backref)

	// ==================== COPY_WITH_LENGTH ====================
	label("copy_with_length")
	emit(0x20)
	jsrExpgolLen2 := placeholder()
	// Add 2 to length (A=zpValLo, C=0 from read_expgol)
	emit(0x69, 0x02) // ADC #2
	emit(0xAA)           // TAX (low counter in X)
	emit(0x90, 0x02)     // BCC +2
	emit(0xE6, zpValHi) // INC zpValHi

	// ==================== COPY_LOOP ====================
	label("copy_loop")
	copyLoopInnerPos := pos()
	emit(0xB1, zpRefLo) // LDA (zpRefLo),Y
	emit(0x91, zpOutLo) // STA (zpOutLo),Y
	emit(0x20)          // JSR checkpoint (A and P are trashable after STA)
	jsrCheckpoint := placeholder()
	emit(0xE6, zpOutLo) // INC zpOutLo
	emit(0xD0, 0x02)    // BNE +2
	emit(0xE6, zpOutHi) // INC zpOutHi
	label("skip_out_hi_inc")
	emit(0xE6, zpRefLo) // INC zpRefLo
	emit(0xD0, 0x02)    // BNE +2
	emit(0xE6, zpRefHi) // INC zpRefHi
	label("skip_ref_hi_inc")
	// Decrement counter with early exit (X = low byte)
	emit(0x8A) // TXA (check X before decrement, sets Z)
	bneNoBorrow := pos()
	emit(0xD0, 0x02)     // BNE +2 (no borrow needed)
	emit(0xC6, zpValHi) // DEC zpValHi (borrow)
	patchRel(bneNoBorrow, pos())
	label("skip_val_hi_dec")
	emit(0xCA)          // DEX
	emit(0x8A)          // TXA (get decremented X into A)
	emit(0x05, zpValHi) // ORA zpValHi (A=0 only if both X and zpValHi are 0)
	bneCopyLoop := copyLoopInnerPos - pos() - 2
	emit(0xD0, byte(bneCopyLoop)) // BNE copy_loop (continue if counter != 0)
	emit(0x4C)                    // JMP main_loop (done)
	jmpMainFromCopy := placeholder()
	patch16(jmpMainFromCopy, base+uint16(mainLoopPos))

	// ==================== READ_GAMMA (k=0) / READ_EXPGOL (k=2) ====================
	// Shared gamma decoding with zpCallerX as flag:
	// - read_gamma: zpCallerX=0, returns gamma-1
	// - read_expgol: zpCallerX=1/2/3, returns (gamma-1)*4 + 2 suffix bits

	// read_gamma entry: set flag to 0, use BIT trick to skip STX
	readGammaPos := label("read_gamma")
	patch16(jsrExpgolLen2, base+uint16(readGammaPos))
	emit(0x84, zpCallerX) // STY zpCallerX (Y=0, flag for gamma path)
	emit(0x2C)            // .byte $2C - BIT abs opcode, skips next 2 bytes

	// read_expgol entry: save X (non-zero) as flag (hidden by BIT when from read_gamma)
	readExpgolPos := label("read_expgol")
	patch16(jsrExpgol1, base+uint16(readExpgolPos))
	patch16(jsrExpgol3, base+uint16(readExpgolPos))
	emit(0x86, zpCallerX) // STX zpCallerX (X=1/2/3, flag for expgol path)

	// Shared gamma reading code
	label("read_gamma_common")
	emit(0xA2, 0x01)     // LDX #$01
	emit(0x86, zpValLo)  // STX zpValLo
	emit(0x84, zpValHi)  // STY zpValHi (Y=0)
	countZerosPos := label("count_zeros")
	emit(0xCA)                        // DEX
	emit(0xE0, terminatorThreshold)   // CPX #(256-TERMINATOR_ZEROS)
	bccTerminatorEarly := pos()
	emit(0xF0, 0x00)    // BEQ terminator
	emit(0x20)
	jsrReadBitGamma := placeholder()
	bccCountZeros := countZerosPos - pos() - 2
	emit(0x90, byte(bccCountZeros)) // BCC count_zeros
	emit(0x8A) // TXA (sets Z flag)
	beqGammaDone := pos()
	emit(0xF0, 0x00) // BEQ gamma_done

	readBitsLoopPos := label("read_gamma_bits")
	emit(0x20)
	jsrReadBitGamma2 := placeholder()
	emit(0x26, zpValLo) // ROL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	emit(0xE8)           // INX
	bneReadBits := readBitsLoopPos - pos() - 2
	emit(0xD0, byte(bneReadBits)) // BNE read_gamma_bits

	gammaDonePos := label("gamma_done")
	patchRel(beqGammaDone, gammaDonePos)

	// Decrement gamma by 1
	emit(0xA5, zpValLo) // LDA zpValLo
	bneNoGammaBorrow := pos()
	emit(0xD0, 0x02)     // BNE +2
	emit(0xC6, zpValHi) // DEC zpValHi
	label("gamma_dec_lo")
	patchRel(bneNoGammaBorrow, pos())
	emit(0xC6, zpValLo) // DEC zpValLo

	// Check flag: zpCallerX=0 means gamma (k=0), else expgol (k=2)
	emit(0xA5, zpCallerX) // LDA zpCallerX
	beqGammaReturn := pos()
	emit(0xF0, 0x00)      // BEQ gamma_return (if flag=0, skip k=2 suffix)

	// k=2 path: shift left by 2, read 2 suffix bits
	emit(0x06, zpValLo) // ASL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	emit(0x06, zpValLo) // ASL zpValLo
	emit(0x26, zpValHi) // ROL zpValHi
	emit(0x98)           // TYA (A=0)
	emit(0x20)
	jsrReadBitExp1 := placeholder()
	emit(0x2A) // ROL A
	emit(0x20)
	jsrReadBitExp2 := placeholder()
	emit(0x2A)           // ROL A (C=0: A is at most 3, bit 7 always 0)
	emit(0x05, zpValLo) // ORA zpValLo
	emit(0x85, zpValLo) // STA zpValLo
	emit(0xA6, zpValHi) // LDX zpValHi
	emit(0x60)           // RTS

	// k=0 path: just return gamma-1
	gammaReturnPos := label("gamma_return")
	patchRel(beqGammaReturn, gammaReturnPos)
	emit(0xA5, zpValLo) // LDA zpValLo (reload decremented value)
	emit(0x18)          // CLC (ensure C=0 for ADC #2)
	emit(0xA6, zpValHi) // LDX zpValHi
	emit(0x60)           // RTS

	// ==================== READ_BIT ====================
	readBitPos := label("read_bit")
	patch16(jsrReadBit1, base+uint16(readBitPos))
	patch16(jsrReadBit2, base+uint16(readBitPos))
	patch16(jsrReadBitLit, base+uint16(readBitPos))
	patch16(jsrReadBit3, base+uint16(readBitPos))
	patch16(jsrReadBit4, base+uint16(readBitPos))
	patch16(jsrReadBit5, base+uint16(readBitPos))
	patch16(jsrReadBitGamma, base+uint16(readBitPos))
	patch16(jsrReadBitGamma2, base+uint16(readBitPos))
	patch16(jsrReadBitExp1, base+uint16(readBitPos))
	patch16(jsrReadBitExp2, base+uint16(readBitPos))

	// Save A once at start, restore once at end
	emit(0x48) // PHA (save A for callers like literal_loop)
	// Checkpoint before ASL so we don't need PHP/PLP
	emit(0x20)
	jsrCheckpointBit := placeholder()
	emit(0x06, zpBitBuf) // ASL zpBitBuf (C = bit, Z = buffer empty?)
	bneReadBitDone := pos()
	emit(0xD0, 0x00) // BNE done (bit still in buffer)
	// Slow path - need to load new byte (A already saved above)
	emit(0xB1, zpSrcLo)  // LDA (zpSrcLo),Y
	emit(0x2A)           // ROL A (C=1 sentinel from ASL becomes new sentinel)
	emit(0x85, zpBitBuf) // STA zpBitBuf
	emit(0xE6, zpSrcLo)  // INC zpSrcLo
	bneSkipSrcHiInc := pos()
	emit(0xD0, 0x00) // BNE skip_src_hi_inc (no page cross)
	emit(0xE6, zpSrcHi)
	skipSrcHiIncPos := label("skip_src_hi_inc")
	patchRel(bneSkipSrcHiInc, skipSrcHiIncPos)
	// C now has the bit from ROL (bit 7 of new byte)
	readBitDonePos := label("read_bit_done")
	patchRel(bneReadBitDone, readBitDonePos)
	emit(0x68) // PLA (restore A)
	emit(0x60) // RTS

	// ==================== TERMINATOR (inlined) ====================
	// Terminator is detected in count_zeros when CPX hits threshold
	// Pop read_expgol/read_gamma return address and exit directly to decompress caller
	terminatorPos := label("terminator")
	patchRel(bccTerminatorEarly, terminatorPos)
	emit(0x68) // PLA (discard read_expgol return lo)
	emit(0x68) // PLA (discard read_expgol return hi)
	emit(0x60) // RTS (return to decompress caller)

	// ==================== CHECKPOINT ====================
	// Called from copy_loop and read_bit (every bit)
	checkpointPos := label("checkpoint")
	patch16(jsrCheckpoint, base+uint16(checkpointPos))
	patch16(jsrCheckpointBit, base+uint16(checkpointPos))
	emit(0x60) // RTS

	return code, labels
}
