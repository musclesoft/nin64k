package pipeline

import (
	"fmt"
	"os"

	"forge/analysis"
	"forge/parse"
	"forge/verify"
)

func LoadAndAnalyze(cfg *Config, songNames []string) (
	[9][]byte,
	[9]parse.ParsedSong,
	[9]analysis.SongAnalysis,
) {
	var rawData [9][]byte
	var parsedSongs [9]parse.ParsedSong
	var analyses [9]analysis.SongAnalysis

	fmt.Println("=== Parse and analyze all songs (frame-based) ===")
	for i, name := range songNames {
		inputPath := cfg.ProjectPath(fmt.Sprintf("uncompressed/%s.raw", name))
		raw, err := os.ReadFile(inputPath)
		if err != nil {
			fmt.Printf("  %s: skipped (not found)\n", name)
			continue
		}

		song := parse.Parse(raw)
		if err := verify.Parse(song); err != nil {
			fmt.Printf("FATAL: %s parse verification failed:\n%v\n", name, err)
			os.Exit(1)
		}

		// Frame-based analysis to determine which orders are actually used
		testFrames := cfg.PartTimes[i]
		maxOrder, playedOrders, needsExtra := analysis.CountMaxOrderGTWithStats(song, testFrames, false)

		// Get static analysis (full order sequence following jumps)
		fullAnal := analysis.Analyze(song, raw)

		// Find the highest order that was actually played
		highestPlayed := 0
		for _, ord := range playedOrders {
			if ord > highestPlayed {
				highestPlayed = ord
			}
		}

		// Determine initial cutoff based on whether prefetch needs the next order.
		// maxOrder = highest order reached (even with 0 frames played)
		// If needsExtra, prefetch will decode maxOrder+1, so include it
		cutoff := maxOrder
		if needsExtra {
			cutoff = maxOrder + 1
		}
		// Cap at max allowed (119 orders = 0-118)
		if cutoff > 118 {
			cutoff = 118
		}

		// Get patterns used by actually played orders
		playedAnal := analysis.AnalyzeWithOrders(song, raw, playedOrders)
		playedPatterns := make(map[uint16]bool)
		for addr := range playedAnal.PatternAddrs {
			playedPatterns[addr] = true
		}

		// Check if orders beyond highestPlayed introduce new patterns
		ordersIntroduceNewPatterns := false
		if cutoff > highestPlayed {
			testOrders := []int{}
			for _, ord := range fullAnal.ReachableOrders {
				if ord <= cutoff {
					testOrders = append(testOrders, ord)
				}
			}
			testAnal := analysis.AnalyzeWithOrders(song, raw, testOrders)
			for addr := range testAnal.PatternAddrs {
				if !playedPatterns[addr] {
					ordersIntroduceNewPatterns = true
					break
				}
			}
		}

		// Build order list: if we need extra orders for prefetch but they introduce new patterns,
		// include the played orders, then add the next order (for prefetch to decode)
		var limitedOrders []int
		duplicateOrderForPrefetch := -1
		if needsExtra && ordersIntroduceNewPatterns {
			// Include played orders, plus the next order
			for _, ord := range fullAnal.ReachableOrders {
				if ord <= highestPlayed {
					limitedOrders = append(limitedOrders, ord)
				}
			}
			// Add the next order (its bitstream will be duplicated from a matching played order)
			duplicateOrderForPrefetch = highestPlayed + 1
			limitedOrders = append(limitedOrders, duplicateOrderForPrefetch)
			cutoff = duplicateOrderForPrefetch
		} else {
			// Normal case: include all orders up to cutoff
			for _, ord := range fullAnal.ReachableOrders {
				if ord <= cutoff {
					limitedOrders = append(limitedOrders, ord)
				}
			}
		}

		// Re-analyze with final limited orders
		anal := analysis.AnalyzeWithOrders(song, raw, limitedOrders)
		if err := verify.Analysis(song, anal); err != nil {
			fmt.Printf("FATAL: %s analysis verification failed:\n%v\n", name, err)
			os.Exit(1)
		}

		// Count extra patterns from orders beyond highestPlayed
		extraPatterns := 0
		for addr := range anal.PatternAddrs {
			if !playedPatterns[addr] {
				extraPatterns++
			}
		}

		// Store duplicate order info for serialization
		if duplicateOrderForPrefetch >= 0 {
			// Helper to check if row 0 of a pattern should skip HR
			shouldSkipHR := func(patAddr uint16) bool {
				pat, ok := song.Patterns[patAddr]
				if !ok || len(pat.Rows) == 0 {
					return true // Empty pattern - skip HR
				}
				row := pat.Rows[0]
				note := row.Note & 0x7F
				effect := row.Effect

				if note == 0 || note == 0x61 {
					return true // No note or key off
				}
				if effect&0x08 != 0 {
					return false // Immediate HR
				}
				if effect == 2 {
					return true // Portamento
				}
				return false // Normal note - do HR
			}

			// Get HR behavior for duplicate order's patterns
			dupHRBehavior := [3]bool{}
			if duplicateOrderForPrefetch < song.NumOrders {
				for ch := 0; ch < 3; ch++ {
					if duplicateOrderForPrefetch < len(song.Orders[ch]) {
						patAddr := song.Orders[ch][duplicateOrderForPrefetch].PatternAddr
						dupHRBehavior[ch] = shouldSkipHR(patAddr)
					}
				}
			}

			// Find an order in playedOrders with matching HR behavior
			bestSource := highestPlayed
			bestMatchScore := -1
			for _, srcOrd := range playedOrders {
				if srcOrd >= song.NumOrders {
					continue
				}
				matchScore := 0
				for ch := 0; ch < 3; ch++ {
					if srcOrd < len(song.Orders[ch]) {
						patAddr := song.Orders[ch][srcOrd].PatternAddr
						srcHRBehavior := shouldSkipHR(patAddr)
						if srcHRBehavior == dupHRBehavior[ch] {
							matchScore++
						}
					}
				}
				if matchScore > bestMatchScore {
					bestMatchScore = matchScore
					bestSource = srcOrd
				}
			}

			anal.DuplicateOrder = duplicateOrderForPrefetch
			anal.DuplicateSource = bestSource

			if name == "d2p" || bestMatchScore < 3 {
				fmt.Printf("  %s: dup=%d from %d (HR match=%d/3), dup HR=[%v,%v,%v]\n",
					name, duplicateOrderForPrefetch, bestSource, bestMatchScore,
					dupHRBehavior[0], dupHRBehavior[1], dupHRBehavior[2])
			}
		}

		fmt.Printf("  %s: %d bytes, %d frames -> %d orders, %d patterns\n",
			name, len(raw), testFrames, len(limitedOrders), len(anal.PatternAddrs))

		rawData[i] = raw
		parsedSongs[i] = song
		analyses[i] = anal
	}

	return rawData, parsedSongs, analyses
}
